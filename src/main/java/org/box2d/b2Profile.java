// Generated by jextract

package org.box2d;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct b2Profile {
 *     float step;
 *     float pairs;
 *     float collide;
 *     float solve;
 *     float mergeIslands;
 *     float prepareStages;
 *     float solveConstraints;
 *     float prepareConstraints;
 *     float integrateVelocities;
 *     float warmStart;
 *     float solveImpulses;
 *     float integratePositions;
 *     float relaxImpulses;
 *     float applyRestitution;
 *     float storeImpulses;
 *     float splitIslands;
 *     float transforms;
 *     float hitEvents;
 *     float refit;
 *     float bullets;
 *     float sleepIslands;
 *     float sensors;
 * }
 * }
 */
public class b2Profile {

    b2Profile() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        Box2D.C_FLOAT.withName("step"),
        Box2D.C_FLOAT.withName("pairs"),
        Box2D.C_FLOAT.withName("collide"),
        Box2D.C_FLOAT.withName("solve"),
        Box2D.C_FLOAT.withName("mergeIslands"),
        Box2D.C_FLOAT.withName("prepareStages"),
        Box2D.C_FLOAT.withName("solveConstraints"),
        Box2D.C_FLOAT.withName("prepareConstraints"),
        Box2D.C_FLOAT.withName("integrateVelocities"),
        Box2D.C_FLOAT.withName("warmStart"),
        Box2D.C_FLOAT.withName("solveImpulses"),
        Box2D.C_FLOAT.withName("integratePositions"),
        Box2D.C_FLOAT.withName("relaxImpulses"),
        Box2D.C_FLOAT.withName("applyRestitution"),
        Box2D.C_FLOAT.withName("storeImpulses"),
        Box2D.C_FLOAT.withName("splitIslands"),
        Box2D.C_FLOAT.withName("transforms"),
        Box2D.C_FLOAT.withName("hitEvents"),
        Box2D.C_FLOAT.withName("refit"),
        Box2D.C_FLOAT.withName("bullets"),
        Box2D.C_FLOAT.withName("sleepIslands"),
        Box2D.C_FLOAT.withName("sensors")
    ).withName("b2Profile");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfFloat step$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("step"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float step
     * }
     */
    public static final OfFloat step$layout() {
        return step$LAYOUT;
    }

    private static final long step$OFFSET = $LAYOUT.byteOffset(groupElement("step"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float step
     * }
     */
    public static final long step$offset() {
        return step$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float step
     * }
     */
    public static float step(MemorySegment struct) {
        return struct.get(step$LAYOUT, step$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float step
     * }
     */
    public static void step(MemorySegment struct, float fieldValue) {
        struct.set(step$LAYOUT, step$OFFSET, fieldValue);
    }

    private static final OfFloat pairs$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("pairs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float pairs
     * }
     */
    public static final OfFloat pairs$layout() {
        return pairs$LAYOUT;
    }

    private static final long pairs$OFFSET = $LAYOUT.byteOffset(groupElement("pairs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float pairs
     * }
     */
    public static final long pairs$offset() {
        return pairs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float pairs
     * }
     */
    public static float pairs(MemorySegment struct) {
        return struct.get(pairs$LAYOUT, pairs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float pairs
     * }
     */
    public static void pairs(MemorySegment struct, float fieldValue) {
        struct.set(pairs$LAYOUT, pairs$OFFSET, fieldValue);
    }

    private static final OfFloat collide$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("collide"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float collide
     * }
     */
    public static final OfFloat collide$layout() {
        return collide$LAYOUT;
    }

    private static final long collide$OFFSET = $LAYOUT.byteOffset(groupElement("collide"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float collide
     * }
     */
    public static final long collide$offset() {
        return collide$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float collide
     * }
     */
    public static float collide(MemorySegment struct) {
        return struct.get(collide$LAYOUT, collide$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float collide
     * }
     */
    public static void collide(MemorySegment struct, float fieldValue) {
        struct.set(collide$LAYOUT, collide$OFFSET, fieldValue);
    }

    private static final OfFloat solve$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("solve"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float solve
     * }
     */
    public static final OfFloat solve$layout() {
        return solve$LAYOUT;
    }

    private static final long solve$OFFSET = $LAYOUT.byteOffset(groupElement("solve"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float solve
     * }
     */
    public static final long solve$offset() {
        return solve$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float solve
     * }
     */
    public static float solve(MemorySegment struct) {
        return struct.get(solve$LAYOUT, solve$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float solve
     * }
     */
    public static void solve(MemorySegment struct, float fieldValue) {
        struct.set(solve$LAYOUT, solve$OFFSET, fieldValue);
    }

    private static final OfFloat mergeIslands$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("mergeIslands"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float mergeIslands
     * }
     */
    public static final OfFloat mergeIslands$layout() {
        return mergeIslands$LAYOUT;
    }

    private static final long mergeIslands$OFFSET = $LAYOUT.byteOffset(groupElement("mergeIslands"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float mergeIslands
     * }
     */
    public static final long mergeIslands$offset() {
        return mergeIslands$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float mergeIslands
     * }
     */
    public static float mergeIslands(MemorySegment struct) {
        return struct.get(mergeIslands$LAYOUT, mergeIslands$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float mergeIslands
     * }
     */
    public static void mergeIslands(MemorySegment struct, float fieldValue) {
        struct.set(mergeIslands$LAYOUT, mergeIslands$OFFSET, fieldValue);
    }

    private static final OfFloat prepareStages$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("prepareStages"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float prepareStages
     * }
     */
    public static final OfFloat prepareStages$layout() {
        return prepareStages$LAYOUT;
    }

    private static final long prepareStages$OFFSET = $LAYOUT.byteOffset(groupElement("prepareStages"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float prepareStages
     * }
     */
    public static final long prepareStages$offset() {
        return prepareStages$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float prepareStages
     * }
     */
    public static float prepareStages(MemorySegment struct) {
        return struct.get(prepareStages$LAYOUT, prepareStages$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float prepareStages
     * }
     */
    public static void prepareStages(MemorySegment struct, float fieldValue) {
        struct.set(prepareStages$LAYOUT, prepareStages$OFFSET, fieldValue);
    }

    private static final OfFloat solveConstraints$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("solveConstraints"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float solveConstraints
     * }
     */
    public static final OfFloat solveConstraints$layout() {
        return solveConstraints$LAYOUT;
    }

    private static final long solveConstraints$OFFSET = $LAYOUT.byteOffset(groupElement("solveConstraints"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float solveConstraints
     * }
     */
    public static final long solveConstraints$offset() {
        return solveConstraints$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float solveConstraints
     * }
     */
    public static float solveConstraints(MemorySegment struct) {
        return struct.get(solveConstraints$LAYOUT, solveConstraints$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float solveConstraints
     * }
     */
    public static void solveConstraints(MemorySegment struct, float fieldValue) {
        struct.set(solveConstraints$LAYOUT, solveConstraints$OFFSET, fieldValue);
    }

    private static final OfFloat prepareConstraints$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("prepareConstraints"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float prepareConstraints
     * }
     */
    public static final OfFloat prepareConstraints$layout() {
        return prepareConstraints$LAYOUT;
    }

    private static final long prepareConstraints$OFFSET = $LAYOUT.byteOffset(groupElement("prepareConstraints"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float prepareConstraints
     * }
     */
    public static final long prepareConstraints$offset() {
        return prepareConstraints$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float prepareConstraints
     * }
     */
    public static float prepareConstraints(MemorySegment struct) {
        return struct.get(prepareConstraints$LAYOUT, prepareConstraints$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float prepareConstraints
     * }
     */
    public static void prepareConstraints(MemorySegment struct, float fieldValue) {
        struct.set(prepareConstraints$LAYOUT, prepareConstraints$OFFSET, fieldValue);
    }

    private static final OfFloat integrateVelocities$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("integrateVelocities"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float integrateVelocities
     * }
     */
    public static final OfFloat integrateVelocities$layout() {
        return integrateVelocities$LAYOUT;
    }

    private static final long integrateVelocities$OFFSET = $LAYOUT.byteOffset(groupElement("integrateVelocities"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float integrateVelocities
     * }
     */
    public static final long integrateVelocities$offset() {
        return integrateVelocities$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float integrateVelocities
     * }
     */
    public static float integrateVelocities(MemorySegment struct) {
        return struct.get(integrateVelocities$LAYOUT, integrateVelocities$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float integrateVelocities
     * }
     */
    public static void integrateVelocities(MemorySegment struct, float fieldValue) {
        struct.set(integrateVelocities$LAYOUT, integrateVelocities$OFFSET, fieldValue);
    }

    private static final OfFloat warmStart$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("warmStart"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float warmStart
     * }
     */
    public static final OfFloat warmStart$layout() {
        return warmStart$LAYOUT;
    }

    private static final long warmStart$OFFSET = $LAYOUT.byteOffset(groupElement("warmStart"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float warmStart
     * }
     */
    public static final long warmStart$offset() {
        return warmStart$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float warmStart
     * }
     */
    public static float warmStart(MemorySegment struct) {
        return struct.get(warmStart$LAYOUT, warmStart$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float warmStart
     * }
     */
    public static void warmStart(MemorySegment struct, float fieldValue) {
        struct.set(warmStart$LAYOUT, warmStart$OFFSET, fieldValue);
    }

    private static final OfFloat solveImpulses$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("solveImpulses"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float solveImpulses
     * }
     */
    public static final OfFloat solveImpulses$layout() {
        return solveImpulses$LAYOUT;
    }

    private static final long solveImpulses$OFFSET = $LAYOUT.byteOffset(groupElement("solveImpulses"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float solveImpulses
     * }
     */
    public static final long solveImpulses$offset() {
        return solveImpulses$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float solveImpulses
     * }
     */
    public static float solveImpulses(MemorySegment struct) {
        return struct.get(solveImpulses$LAYOUT, solveImpulses$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float solveImpulses
     * }
     */
    public static void solveImpulses(MemorySegment struct, float fieldValue) {
        struct.set(solveImpulses$LAYOUT, solveImpulses$OFFSET, fieldValue);
    }

    private static final OfFloat integratePositions$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("integratePositions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float integratePositions
     * }
     */
    public static final OfFloat integratePositions$layout() {
        return integratePositions$LAYOUT;
    }

    private static final long integratePositions$OFFSET = $LAYOUT.byteOffset(groupElement("integratePositions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float integratePositions
     * }
     */
    public static final long integratePositions$offset() {
        return integratePositions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float integratePositions
     * }
     */
    public static float integratePositions(MemorySegment struct) {
        return struct.get(integratePositions$LAYOUT, integratePositions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float integratePositions
     * }
     */
    public static void integratePositions(MemorySegment struct, float fieldValue) {
        struct.set(integratePositions$LAYOUT, integratePositions$OFFSET, fieldValue);
    }

    private static final OfFloat relaxImpulses$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("relaxImpulses"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float relaxImpulses
     * }
     */
    public static final OfFloat relaxImpulses$layout() {
        return relaxImpulses$LAYOUT;
    }

    private static final long relaxImpulses$OFFSET = $LAYOUT.byteOffset(groupElement("relaxImpulses"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float relaxImpulses
     * }
     */
    public static final long relaxImpulses$offset() {
        return relaxImpulses$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float relaxImpulses
     * }
     */
    public static float relaxImpulses(MemorySegment struct) {
        return struct.get(relaxImpulses$LAYOUT, relaxImpulses$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float relaxImpulses
     * }
     */
    public static void relaxImpulses(MemorySegment struct, float fieldValue) {
        struct.set(relaxImpulses$LAYOUT, relaxImpulses$OFFSET, fieldValue);
    }

    private static final OfFloat applyRestitution$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("applyRestitution"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float applyRestitution
     * }
     */
    public static final OfFloat applyRestitution$layout() {
        return applyRestitution$LAYOUT;
    }

    private static final long applyRestitution$OFFSET = $LAYOUT.byteOffset(groupElement("applyRestitution"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float applyRestitution
     * }
     */
    public static final long applyRestitution$offset() {
        return applyRestitution$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float applyRestitution
     * }
     */
    public static float applyRestitution(MemorySegment struct) {
        return struct.get(applyRestitution$LAYOUT, applyRestitution$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float applyRestitution
     * }
     */
    public static void applyRestitution(MemorySegment struct, float fieldValue) {
        struct.set(applyRestitution$LAYOUT, applyRestitution$OFFSET, fieldValue);
    }

    private static final OfFloat storeImpulses$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("storeImpulses"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float storeImpulses
     * }
     */
    public static final OfFloat storeImpulses$layout() {
        return storeImpulses$LAYOUT;
    }

    private static final long storeImpulses$OFFSET = $LAYOUT.byteOffset(groupElement("storeImpulses"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float storeImpulses
     * }
     */
    public static final long storeImpulses$offset() {
        return storeImpulses$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float storeImpulses
     * }
     */
    public static float storeImpulses(MemorySegment struct) {
        return struct.get(storeImpulses$LAYOUT, storeImpulses$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float storeImpulses
     * }
     */
    public static void storeImpulses(MemorySegment struct, float fieldValue) {
        struct.set(storeImpulses$LAYOUT, storeImpulses$OFFSET, fieldValue);
    }

    private static final OfFloat splitIslands$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("splitIslands"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float splitIslands
     * }
     */
    public static final OfFloat splitIslands$layout() {
        return splitIslands$LAYOUT;
    }

    private static final long splitIslands$OFFSET = $LAYOUT.byteOffset(groupElement("splitIslands"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float splitIslands
     * }
     */
    public static final long splitIslands$offset() {
        return splitIslands$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float splitIslands
     * }
     */
    public static float splitIslands(MemorySegment struct) {
        return struct.get(splitIslands$LAYOUT, splitIslands$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float splitIslands
     * }
     */
    public static void splitIslands(MemorySegment struct, float fieldValue) {
        struct.set(splitIslands$LAYOUT, splitIslands$OFFSET, fieldValue);
    }

    private static final OfFloat transforms$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("transforms"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float transforms
     * }
     */
    public static final OfFloat transforms$layout() {
        return transforms$LAYOUT;
    }

    private static final long transforms$OFFSET = $LAYOUT.byteOffset(groupElement("transforms"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float transforms
     * }
     */
    public static final long transforms$offset() {
        return transforms$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float transforms
     * }
     */
    public static float transforms(MemorySegment struct) {
        return struct.get(transforms$LAYOUT, transforms$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float transforms
     * }
     */
    public static void transforms(MemorySegment struct, float fieldValue) {
        struct.set(transforms$LAYOUT, transforms$OFFSET, fieldValue);
    }

    private static final OfFloat hitEvents$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("hitEvents"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float hitEvents
     * }
     */
    public static final OfFloat hitEvents$layout() {
        return hitEvents$LAYOUT;
    }

    private static final long hitEvents$OFFSET = $LAYOUT.byteOffset(groupElement("hitEvents"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float hitEvents
     * }
     */
    public static final long hitEvents$offset() {
        return hitEvents$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float hitEvents
     * }
     */
    public static float hitEvents(MemorySegment struct) {
        return struct.get(hitEvents$LAYOUT, hitEvents$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float hitEvents
     * }
     */
    public static void hitEvents(MemorySegment struct, float fieldValue) {
        struct.set(hitEvents$LAYOUT, hitEvents$OFFSET, fieldValue);
    }

    private static final OfFloat refit$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("refit"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float refit
     * }
     */
    public static final OfFloat refit$layout() {
        return refit$LAYOUT;
    }

    private static final long refit$OFFSET = $LAYOUT.byteOffset(groupElement("refit"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float refit
     * }
     */
    public static final long refit$offset() {
        return refit$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float refit
     * }
     */
    public static float refit(MemorySegment struct) {
        return struct.get(refit$LAYOUT, refit$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float refit
     * }
     */
    public static void refit(MemorySegment struct, float fieldValue) {
        struct.set(refit$LAYOUT, refit$OFFSET, fieldValue);
    }

    private static final OfFloat bullets$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("bullets"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float bullets
     * }
     */
    public static final OfFloat bullets$layout() {
        return bullets$LAYOUT;
    }

    private static final long bullets$OFFSET = $LAYOUT.byteOffset(groupElement("bullets"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float bullets
     * }
     */
    public static final long bullets$offset() {
        return bullets$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float bullets
     * }
     */
    public static float bullets(MemorySegment struct) {
        return struct.get(bullets$LAYOUT, bullets$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float bullets
     * }
     */
    public static void bullets(MemorySegment struct, float fieldValue) {
        struct.set(bullets$LAYOUT, bullets$OFFSET, fieldValue);
    }

    private static final OfFloat sleepIslands$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("sleepIslands"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float sleepIslands
     * }
     */
    public static final OfFloat sleepIslands$layout() {
        return sleepIslands$LAYOUT;
    }

    private static final long sleepIslands$OFFSET = $LAYOUT.byteOffset(groupElement("sleepIslands"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float sleepIslands
     * }
     */
    public static final long sleepIslands$offset() {
        return sleepIslands$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float sleepIslands
     * }
     */
    public static float sleepIslands(MemorySegment struct) {
        return struct.get(sleepIslands$LAYOUT, sleepIslands$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float sleepIslands
     * }
     */
    public static void sleepIslands(MemorySegment struct, float fieldValue) {
        struct.set(sleepIslands$LAYOUT, sleepIslands$OFFSET, fieldValue);
    }

    private static final OfFloat sensors$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("sensors"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float sensors
     * }
     */
    public static final OfFloat sensors$layout() {
        return sensors$LAYOUT;
    }

    private static final long sensors$OFFSET = $LAYOUT.byteOffset(groupElement("sensors"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float sensors
     * }
     */
    public static final long sensors$offset() {
        return sensors$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float sensors
     * }
     */
    public static float sensors(MemorySegment struct) {
        return struct.get(sensors$LAYOUT, sensors$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float sensors
     * }
     */
    public static void sensors(MemorySegment struct, float fieldValue) {
        struct.set(sensors$LAYOUT, sensors$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

